<?php// This file is part of INTUITEL http://www.intuitel.eu as an adaptor for Moodle http://moodle.org///// INTUITEL for Moodle is free software: you can redistribute it and/or modify// it under the terms of the GNU General Public License as published by// the Free Software Foundation, either version 3 of the License, or// (at your option) any later version.//// INTUITEL for Moodle is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.//// You should have received a copy of the GNU General Public License// along with INTUITEL for Moodle Adaptor.  If not, see <http://www.gnu.org/licenses/>./** * Parsing and writing XML messages for INTUITEL * * @package    block_intuitel * @author Juan Pablo de Castro, Elena Verdú. * @copyright  2015 Intuitel Consortium * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later */namespace intuitel;require_once('idFactory.php');require_once('exceptions.php');define('INTUITEL_LPM_NAMESPACE_URI', "http://www.intuitel.eu/public/intui_DMLPM.xsd");define('INTUITEL_LMS_NAMESPACE_URI', "http://www.intuitel.eu/public/intui_DMLMS.xsd");define('INTUITEL_RR_NAMESPACE_URI', "http://www.intuitel.eu/public/intui_DMRR.xsd");/** * Parsing and writing XML messages for INTUITEL * * @package    block_intuitel * @author Juan Pablo de Castro, Elena Verdú. * @copyright  2015 Intuitel Consortium * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later */class IntuitelXMLSerializer{	static 	$intuitel_template = <<<XML<?xml version="1.0" encoding="UTF-8"?><intuilms:INTUITEL xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.intuitel.eu/public/intui_DMLMS.xsd http://www.intuitel.de/public/intui_DMLMS.xsd"xmlns:intuilms="http://www.intuitel.eu/public/intui_DMLMS.xsd"/>XML;	/**	 *	 * @return \SimpleXMLElement initialized with INTUITEL root node and namespaces.	 */	public static function getIntuitelXMLTemplate()	{		return new \SimpleXMLElement(IntuitelXMLSerializer::$intuitel_template);	}	/**	 *	 * @param \SimpleXMLElement $element	 * @param string $name	 * @throws ProtocolErrorException	 * @return string	 */	public static function get_required_attribute($element,$name)	{// 		if (empty($element)) // Empty refers to an element with no value TODO remove this// 		{// 			throw new ProtocolErrorException("Empty element for attribute $name.");// 		}		$atts = (array)$element->attributes();		$atts = (array)$atts['@attributes'];// 		var_dump($atts);		if (array_key_exists($name,$atts)===false)			$value='';		else			$value=(string) $atts[$name];		if ($value=='')			throw new ProtocolErrorException("Missing attribute $name.");		else			return $value;	}	/**	 *	 * @param \SimpleXMLElement $element	 * @param unknown $name	 * @throws ProtocolErrorException	 * @return \SimpleXMLElementx	 */	public static function get_required_element(\SimpleXMLElement $element,$name)	{		$result=$element->$name;		if(empty($result))			throw new ProtocolErrorException("Required element $name not found!");		else			return $result;	}/** * * @param array(array(IntuitelLO))  'mId'=>array($los) * @return string xml message */	public function serializeLoMapping(array $los,$mid=null)	{	    if (isset($mid)) // retain old interface for compatibility	    {	        $multiple_los=array();	        $multiple_los[$mid]=$los;	    }	    else	    {	        $multiple_los=$los;	    }		$response = IntuitelXMLSerializer::getIntuitelXMLTemplate();		foreach ($multiple_los as $mid=>$los)		{		    $lom_xml=$response->addChild('LoMapping',null,INTUITEL_LMS_NAMESPACE_URI);		    $lom_xml->addAttribute('mId', $mid);		    foreach($los as $lo)			{		    $lo_xml= $lom_xml->addChild('LearningObject',null,INTUITEL_LMS_NAMESPACE_URI);		    $lo_xml->addAttribute('id', $lo->getloId()->id());				$loattributes= $lo->getValuedAttributes();				foreach($loattributes as $name=>$value)					{						// allow $value to be an array						if (is_array($value))						{							$values=$value;						}						else							$values=array($value);						foreach ($values as $val_element)						{							$data_xml = $lo_xml->addChild('Data',null,INTUITEL_LMS_NAMESPACE_URI);							$data_xml->addAttribute('name', $name);							if ($val_element instanceof LOId)								$val_element=$val_element->id();							$data_xml->addAttribute('value', $val_element);						}					}			}		}		return IntuitelXMLSerializer::return_xml($response);	}	function serializeLMSProfile($mid,array $properties)	{		$response = IntuitelXMLSerializer::getIntuitelXMLTemplate();		$prof_xml= $response->addChild('LmsProfile',null,INTUITEL_LMS_NAMESPACE_URI);		$prof_xml->addAttribute('mId', $mid);			foreach($properties as $propname=>$value)			{				$data_xml = $prof_xml->addChild('Data',null,INTUITEL_LMS_NAMESPACE_URI);				$data_xml->addAttribute('name', $propname);				$data_xml->addAttribute('value', $value);			}	return IntuitelXMLSerializer::return_xml($response);	}	function parse_mapping_request($loMapping)	{		$datas = $loMapping->Data;		//if (count($datas)==0)		//	throw new ProtocolErrorException('No Data element detected!:'.$loMapping->asXML(),400);		$params=array();		foreach($datas as $data)		{			$atts= $data->attributes();			$name= $atts['name'];			if ($name=='')				throw new ProtocolErrorException('Data name can\'t be null.');			$val = $atts['value'];			if ($name == 'hasChildren') // mutivalued param			{			   if (empty($params[(string)$name]))			     $val_array=array();			   else			     $val_array = $params[(string)$name];			   $val_array[]=(string)$val;			   $params[(string)$name]=$val_array;			}			else			{			   $params[(string)$name]=(string)$val;			}		}		return $params;	}	public static function return_xml(\SimpleXMLElement $response=null)	{		if (!isset($response))			throw new ProtocolErrorException("Can´t process message.");		return IntuitelXMLSerializer::formatXmlString($response->asXML());	}	static function formatXmlString($xml) {		// add marker linefeeds to aid the pretty-tokeniser (adds a linefeed between all tag-end boundaries)		$xml = preg_replace('/(>)(<)(\/*)/', "$1\n$2$3", $xml);		// now indent the tags		$token      = strtok($xml, "\n");		$result     = ''; // holds formatted version as it is built		$pad        = 0; // initial indent		$matches    = array(); // returns from preg_matches()		// scan each line and adjust indent based on opening/closing tags		while ($token !== false) :		// test for the various tag states		// 1. open and closing tags on same line - no change		if (preg_match('/.+<\/\w[^>]*>$/', $token, $matches)) :		$indent=0;		// 2. closing tag - outdent now		elseif (preg_match('/^<\/\w/', $token, $matches)) :                $pad--;		// 3. opening tag - don't pad this one, only subsequent tags		elseif (preg_match('/^<\w[^>]*[^\/]>.*$/', $token, $matches)) :                $indent=1;		// 4. no indentation needed		else :		$indent = 0;		endif;		// pad the line with the required number of leading spaces		$line    = str_pad($token, strlen($token)+$pad, ' ', STR_PAD_LEFT);		$result .= $line . "\n"; // add to the cumulative result, with linefeed		$token   = strtok("\n"); // get the next token		$pad    += $indent; // update the pad size for subsequent lines		endwhile;		return $result;	}}